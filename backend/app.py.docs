"""
BU Study Spots Backend API

This module provides the backend API for the BU Study Spots application.
It serves study space data to the frontend, processes availability based on current time,
and calculates distances between user location and study spaces.

The API exposes endpoints to retrieve study space information and test connectivity.
"""

from flask import Flask, jsonify, request
from datetime import datetime, timedelta
import json
import math
import os

app = Flask(__name__)

def haversine(lat1, lon1, lat2, lon2):
    """
    Calculate the great-circle distance between two points on Earth.
    
    Uses the Haversine formula to compute the distance between two geographic
    coordinates in kilometers.
    
    Args:
        lat1 (float): Latitude of the first point in degrees
        lon1 (float): Longitude of the first point in degrees
        lat2 (float): Latitude of the second point in degrees
        lon2 (float): Longitude of the second point in degrees
        
    Returns:
        float: Distance between the two points in kilometers
        
    Example:
        >>> haversine(42.3505, -71.1097, 42.3601, -71.0589)
        4.3215
    """
    R = 6371  # Earth radius in kilometers
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = math.sin(dlat / 2) ** 2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return R * c 

def get_slot_status(current_time, start_time_str, end_time_str):
    """
    Determine the availability status of a study space based on its operating hours.
    
    This function compares the current time with the start and end times of a study space
    to determine if it's currently available, upcoming, unavailable, or has passed.
    It handles special cases like time slots that span midnight.
    
    Args:
        current_time (datetime.time): Current time as a datetime.time object
        start_time_str (str): Start time of the slot in "HH:MM:SS" format
        end_time_str (str): End time of the slot in "HH:MM:SS" format
        
    Returns:
        str: Status string, one of:
            - "available": The study space is currently open
            - "upcoming": The study space will open within the next 20 minutes
            - "unavailable": The study space is closed and not opening soon
            - "passed": The study space was open earlier but is now closed
            
    Example:
        >>> current_time = datetime.now().time()
        >>> get_slot_status(current_time, "09:00:00", "17:00:00")
        "available"  # if current time is between 9 AM and 5 PM
    """
    start_time = datetime.strptime(start_time_str, "%H:%M:%S").time()
    end_time = datetime.strptime(end_time_str, "%H:%M:%S").time()
    
    # Check if the time spans midnight (end_time is earlier than start_time)
    spans_midnight = end_time < start_time
    
    # Calculate time until opening
    time_until = datetime.combine(datetime.today(), start_time) - datetime.combine(datetime.today(), current_time)
    time_until = time_until.total_seconds() / 60
    
    # For times that span midnight, we need special handling
    if spans_midnight:
        # If current time is after start time or before end time, it's available
        if start_time <= current_time or current_time <= end_time:
            return "available"
        # If we're approaching the start time
        elif time_until > 0 and time_until < 20:
            return "upcoming"
        else:
            return "unavailable"
    else:
        # Standard time slot handling (same day)
        if time_until > 0 and time_until < 20:
            return "upcoming"
        elif start_time <= current_time <= end_time:
            return "available"
        elif current_time > end_time:
            return "passed"
        else:
            return "unavailable"

@app.route('/api/test', methods=['GET'])
def test():
    """
    Test endpoint to verify API connectivity.
    
    This simple endpoint returns a success message to confirm that the API is running
    and accessible.
    
    Returns:
        JSON: A simple message indicating the API is working
        
    Example:
        >>> curl http://localhost:8080/api/test
        {"message": "Test route is working!"}
    """
    return jsonify({"message": "Test route is working!"})


@app.route('/api/open-classrooms', methods=['GET', 'POST'])
def get_open_classrooms():
    """
    Retrieve all study spaces with their availability status.
    
    This endpoint returns information about all study spaces, including their
    building details, room schedules, and availability status based on the current time.
    
    When called with POST and user coordinates, it also calculates and includes
    the distance to each location, sorting the results by proximity.
    
    Methods:
        GET: Returns all study spaces without distance calculations
        POST: Accepts user location data and returns study spaces with distance calculations
        
    POST Request Body:
        {
          "lat": 42.3505,  # User's latitude
          "lng": -71.1097  # User's longitude
        }
        
    Returns:
        JSON: Array of building objects with the following structure:
        [
          {
            "building": "Building Name",
            "building_code": "Code",
            "building_status": "available|upcoming|unavailable",
            "rooms": {
              "Room Number": {
                "slots": [
                  {
                    "StartTime": "HH:MM:SS",
                    "EndTime": "HH:MM:SS",
                    "Status": "available|upcoming|unavailable|passed"
                  }
                ]
              }
            },
            "coords": [longitude, latitude],
            "distance": 0.5  # Only included if user location is provided
          }
        ]
        
    Example:
        >>> curl -X POST -H "Content-Type: application/json" -d '{"lat": 42.3505, "lng": -71.1097}' http://localhost:8080/api/open-classrooms
    """
    user_lat = 0
    user_lng = 0

    if request.method == 'GET':
        print("get method")

    if request.method == 'POST':
        print("Method post")
        user_location = request.get_json()

        if user_location is None:
            return jsonify({"error": "No data provided"}), 400

        user_lat = user_location.get('lat')
        user_lng = user_location.get('lng')

        if user_lat is None or user_lng is None:
            return jsonify({"error": "Invalid location data. 'lat' and 'lng' are required."}), 400
    
    # Load Boston University data from JSON file
    current_dir = os.path.dirname(os.path.abspath(__file__))
    bu_data_path = os.path.join(current_dir, 'bu_study_spaces.json')
    
    with open(bu_data_path, 'r') as f:
        bu_data = json.load(f)

    current_time = datetime.now().time()
    building_info_list = []

    for building in bu_data:
        building_name = building['name']
        building_code = building['code']
        building_coords = building['coordinates']  # [longitude, latitude]
        
        rooms = {}
        building_status = "unavailable"

        for room in building['rooms']:
            room_number = room['roomNumber']
            schedule = room['schedule']
            
            if schedule:
                slots = schedule[0]['Slots'] if schedule else []
                slots_with_status = []

                for slot in slots:
                    start_time = slot['StartTime']
                    end_time = slot['EndTime']

                    status = get_slot_status(current_time, start_time, end_time)

                    if building_status != "available" and status == "available":
                        building_status = "available"
                    elif building_status == "unavailable" and status == "upcoming":
                        building_status = "upcoming"

                    if (status != "passed"):
                        slots_with_status.append({
                            "StartTime": start_time,
                            "EndTime": end_time,
                            "Status": status
                        })
                
                if slots_with_status:
                    rooms[room_number] = {
                        "slots": slots_with_status
                    }

        building_info = {
            "building": building_name,
            "building_code": building_code,
            "building_status": building_status,
            "rooms": rooms,
            "coords": building_coords,
            "distance": haversine(user_lat, user_lng, building_coords[1], building_coords[0]) if user_lat != 0 and user_lng != 0 else 0
        }

        if rooms:
            building_info_list.append(building_info)
    
    if user_lat != 0 and user_lng != 0:
        building_info_list = sorted(building_info_list, key=lambda x: x['distance'])
    
    return jsonify(building_info_list)

if __name__ == '__main__':
    """
    Run the Flask application when executed directly.
    
    This block is executed when the script is run directly (not imported as a module).
    It starts the Flask development server with debugging enabled.
    """
    app.run(host='0.0.0.0', port=8080, debug=True) 